# Systèmes d'exploitation et réseaux

## Introduction

Les systèmes d'exploitation et les réseaux forment l'infrastructure logicielle qui permet aux ordinateurs de fonctionner et de communiquer. Ces concepts sont essentiels pour comprendre le fonctionnement des systèmes informatiques modernes.

---

## Systèmes d'exploitation

### Définition et rôles

#### Qu'est-ce qu'un système d'exploitation ?

Un système d'exploitation (OS) est un logiciel qui :
- Gère les ressources matérielles
- Fournit une interface entre l'utilisateur et le matériel
- Exécute et contrôle les programmes
- Assure la sécurité et l'isolation

#### Rôles principaux

**Gestionnaire de ressources :**
- Processeur (ordonnancement)
- Mémoire (allocation/libération)
- Stockage (système de fichiers)
- Périphériques (pilotes)

**Interface utilisateur :**
- Interface graphique (GUI)
- Interface en ligne de commande (CLI)
- APIs pour les programmes

**Sécurité :**
- Authentification des utilisateurs
- Contrôle d'accès aux ressources
- Isolation des processus

### Architecture d'un système d'exploitation

```
┌─────────────────────────────────────────────────────────┐
│                 APPLICATIONS                            │
├─────────────────────────────────────────────────────────┤
│              INTERFACE UTILISATEUR                     │
│           (Shell, Interface graphique)                 │
├─────────────────────────────────────────────────────────┤
│                APPELS SYSTÈME                          │
│              (System calls)                            │
├─────────────────────────────────────────────────────────┤
│                   NOYAU (Kernel)                       │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────────────┐ │
│  │ Gestion des │ │ Gestion de  │ │    Système de       │ │
│  │ processus   │ │ la mémoire  │ │    fichiers         │ │
│  └─────────────┘ └─────────────┘ └─────────────────────┘ │
│  ┌─────────────────────────────────────────────────────┐ │
│  │           Gestion des périphériques                │ │
│  │              (Pilotes - Drivers)                   │ │
│  └─────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────┤
│                   MATÉRIEL                             │
│    CPU    │   Mémoire   │  Disques  │  Périphériques   │
└─────────────────────────────────────────────────────────┘
```

### Gestion des processus

#### Qu'est-ce qu'un processus ?

Un processus est un programme en cours d'exécution, caractérisé par :
- **Code** : instructions du programme
- **Données** : variables et structures
- **Pile** : appels de fonctions et variables locales
- **Tas** : allocation dynamique
- **Registres** : état du processeur
- **Compteur de programme** : prochaine instruction

#### États d'un processus

```
    ┌─────────┐
    │ NOUVEAU │
    └────┬────┘
         │ admission
         ▼
    ┌─────────┐ ordonnanceur ┌─────────┐
    │  PRÊT   │◄─────────────┤EN COURS │
    └────┬────┘              └────┬────┘
         ▲                        │
         │ E/S terminée           │ E/S requise
         │                        ▼
    ┌─────────┐              ┌─────────┐
    │BLOQUÉ   │              │TERMINÉ  │
    └─────────┘              └─────────┘
```

#### Ordonnancement des processus

**Algorithmes d'ordonnancement :**

**FIFO (First In, First Out) :**
- Premier arrivé, premier servi
- Simple mais peut causer de l'attente

**SJF (Shortest Job First) :**
- Processus le plus court d'abord
- Optimal pour le temps d'attente moyen
- Difficile à prédire

**Round Robin :**
- Chaque processus reçoit un quantum de temps
- Équitable mais peut augmenter le temps de réponse

**Priorités :**
- Processus avec priorité plus élevée d'abord
- Risque de famine pour les basses priorités

#### Simulation d'un ordonnanceur

```python
from collections import deque
import time

class Processus:
    def __init__(self, pid, duree_execution, priorite=0):
        self.pid = pid
        self.duree_execution = duree_execution
        self.temps_restant = duree_execution
        self.priorite = priorite
        self.temps_arrivee = time.time()
        self.temps_debut = None
        self.temps_fin = None
        self.etat = "NOUVEAU"
    
    def __str__(self):
        return f"P{self.pid}(durée:{self.duree_execution}, restant:{self.temps_restant})"

class OrdonnanceurRoundRobin:
    def __init__(self, quantum=2):
        self.quantum = quantum
        self.file_prets = deque()
        self.processus_en_cours = None
        self.temps_actuel = 0
        self.historique = []
    
    def ajouter_processus(self, processus):
        """Ajoute un processus à la file des prêts"""
        processus.etat = "PRÊT"
        self.file_prets.append(processus)
        print(f"Temps {self.temps_actuel}: {processus} ajouté à la file")
    
    def executer_cycle(self):
        """Exécute un cycle d'ordonnancement"""
        if self.processus_en_cours is None and self.file_prets:
            # Sélectionner le prochain processus
            self.processus_en_cours = self.file_prets.popleft()
            self.processus_en_cours.etat = "EN_COURS"
            if self.processus_en_cours.temps_debut is None:
                self.processus_en_cours.temps_debut = self.temps_actuel
            print(f"Temps {self.temps_actuel}: Démarrage de {self.processus_en_cours}")
        
        if self.processus_en_cours:
            # Exécuter le processus pendant le quantum ou jusqu'à la fin
            temps_execution = min(self.quantum, self.processus_en_cours.temps_restant)
            
            for t in range(temps_execution):
                self.historique.append(f"P{self.processus_en_cours.pid}")
                self.processus_en_cours.temps_restant -= 1
                self.temps_actuel += 1
                
                if self.processus_en_cours.temps_restant == 0:
                    # Processus terminé
                    self.processus_en_cours.temps_fin = self.temps_actuel
                    self.processus_en_cours.etat = "TERMINÉ"
                    print(f"Temps {self.temps_actuel}: {self.processus_en_cours} terminé")
                    self.processus_en_cours = None
                    break
            
            # Si le processus n'est pas terminé, le remettre en file
            if self.processus_en_cours and self.processus_en_cours.temps_restant > 0:
                print(f"Temps {self.temps_actuel}: Quantum écoulé pour {self.processus_en_cours}")
                self.processus_en_cours.etat = "PRÊT"
                self.file_prets.append(self.processus_en_cours)
                self.processus_en_cours = None
    
    def executer_jusqu_fin(self):
        """Exécute tous les processus jusqu'à la fin"""
        while self.file_prets or self.processus_en_cours:
            self.executer_cycle()
        
        print(f"\nOrdonnancement terminé en {self.temps_actuel} unités de temps")
        print(f"Séquence d'exécution: {' -> '.join(self.historique)}")
    
    def calculer_statistiques(self, processus_list):
        """Calcule les statistiques de performance"""
        temps_attente_total = 0
        temps_reponse_total = 0
        
        print("\nStatistiques:")
        for p in processus_list:
            temps_attente = p.temps_fin - p.temps_arrivee - p.duree_execution
            temps_reponse = p.temps_debut - p.temps_arrivee
            temps_attente_total += temps_attente
            temps_reponse_total += temps_reponse
            
            print(f"P{p.pid}: Attente={temps_attente}, Réponse={temps_reponse}, "
                  f"Turnaround={p.temps_fin - p.temps_arrivee}")
        
        print(f"Temps d'attente moyen: {temps_attente_total / len(processus_list):.1f}")
        print(f"Temps de réponse moyen: {temps_reponse_total / len(processus_list):.1f}")

# Exemple d'utilisation
if __name__ == "__main__":
    # Créer des processus
    processus = [
        Processus(1, 5),  # P1: 5 unités de temps
        Processus(2, 3),  # P2: 3 unités de temps
        Processus(3, 8),  # P3: 8 unités de temps
        Processus(4, 2),  # P4: 2 unités de temps
    ]
    
    # Créer l'ordonnanceur
    ordonnanceur = OrdonnanceurRoundRobin(quantum=3)
    
    # Ajouter les processus
    for p in processus:
        ordonnanceur.ajouter_processus(p)
    
    # Exécuter l'ordonnancement
    ordonnanceur.executer_jusqu_fin()
    
    # Calculer les statistiques
    ordonnanceur.calculer_statistiques(processus)
```

### Gestion de la mémoire

#### Allocation de mémoire

**Allocation contiguë :**
- Chaque processus occupe un bloc continu
- Fragmentation externe
- Compactage nécessaire

**Allocation paginée :**
- Mémoire divisée en pages de taille fixe
- Pas de fragmentation externe
- Table des pages pour la traduction d'adresses

**Allocation segmentée :**
- Mémoire divisée en segments de taille variable
- Correspond à la structure logique du programme
- Fragmentation externe possible

#### Mémoire virtuelle

**Principe :**
- Illusion d'un espace mémoire plus grand
- Pages stockées sur disque (swap)
- Chargement à la demande (demand paging)

**Algorithmes de remplacement de pages :**

**FIFO :**
- Remplace la page la plus ancienne
- Simple mais pas optimal

**LRU (Least Recently Used) :**
- Remplace la page la moins récemment utilisée
- Bon mais coûteux à implémenter

**Algorithme de l'horloge :**
- Approximation de LRU
- Bit de référence pour chaque page

#### Simulation de la mémoire virtuelle

```python
class PageMemoire:
    def __init__(self, numero, donnees=None):
        self.numero = numero
        self.donnees = donnees or f"Page_{numero}"
        self.bit_reference = False
        self.temps_acces = 0

class GestionnaireMemoire:
    def __init__(self, taille_memoire_physique, taille_page=4096):
        self.taille_memoire_physique = taille_memoire_physique
        self.taille_page = taille_page
        self.nb_pages_physiques = taille_memoire_physique // taille_page
        
        # Mémoire physique (frames)
        self.memoire_physique = [None] * self.nb_pages_physiques
        
        # Table des pages (virtuel -> physique)
        self.table_pages = {}
        
        # Statistiques
        self.defauts_page = 0
        self.acces_total = 0
        self.temps_actuel = 0
    
    def acceder_page(self, numero_page_virtuelle):
        """Accède à une page virtuelle"""
        self.acces_total += 1
        self.temps_actuel += 1
        
        # Vérifier si la page est en mémoire physique
        if numero_page_virtuelle in self.table_pages:
            # Page hit
            frame = self.table_pages[numero_page_virtuelle]
            page = self.memoire_physique[frame]
            page.bit_reference = True
            page.temps_acces = self.temps_actuel
            print(f"Page {numero_page_virtuelle}: HIT (frame {frame})")
            return page.donnees
        else:
            # Page fault
            self.defauts_page += 1
            print(f"Page {numero_page_virtuelle}: MISS - Défaut de page")
            return self.charger_page(numero_page_virtuelle)
    
    def charger_page(self, numero_page_virtuelle):
        """Charge une page depuis le stockage secondaire"""
        # Simuler le chargement depuis le disque
        nouvelle_page = PageMemoire(numero_page_virtuelle)
        nouvelle_page.temps_acces = self.temps_actuel
        
        # Trouver une frame libre ou en libérer une
        frame_libre = self.trouver_frame_libre()
        
        if frame_libre is not None:
            # Frame libre disponible
            self.memoire_physique[frame_libre] = nouvelle_page
            self.table_pages[numero_page_virtuelle] = frame_libre
            print(f"Page {numero_page_virtuelle} chargée dans frame {frame_libre}")
        else:
            # Pas de frame libre, utiliser l'algorithme de remplacement
            frame_victime = self.algorithme_remplacement_lru()
            page_victime = self.memoire_physique[frame_victime]
            
            # Retirer l'ancienne page
            del self.table_pages[page_victime.numero]
            print(f"Page {page_victime.numero} évincée de frame {frame_victime}")
            
            # Charger la nouvelle page
            self.memoire_physique[frame_victime] = nouvelle_page
            self.table_pages[numero_page_virtuelle] = frame_victime
            print(f"Page {numero_page_virtuelle} chargée dans frame {frame_victime}")
        
        return nouvelle_page.donnees
    
    def trouver_frame_libre(self):
        """Trouve une frame libre en mémoire physique"""
        for i, frame in enumerate(self.memoire_physique):
            if frame is None:
                return i
        return None
    
    def algorithme_remplacement_lru(self):
        """Algorithme LRU pour le remplacement de pages"""
        temps_acces_min = float('inf')
        frame_victime = 0
        
        for i, page in enumerate(self.memoire_physique):
            if page and page.temps_acces < temps_acces_min:
                temps_acces_min = page.temps_acces
                frame_victime = i
        
        return frame_victime
    
    def afficher_etat(self):
        """Affiche l'état actuel de la mémoire"""
        print("\nÉtat de la mémoire physique:")
        for i, page in enumerate(self.memoire_physique):
            if page:
                print(f"Frame {i}: Page {page.numero} (accès: {page.temps_acces})")
            else:
                print(f"Frame {i}: LIBRE")
        
        print(f"\nTable des pages: {self.table_pages}")
        print(f"Défauts de page: {self.defauts_page}/{self.acces_total} "
              f"({self.defauts_page/self.acces_total*100:.1f}%)")

# Exemple d'utilisation
if __name__ == "__main__":
    # Créer un gestionnaire avec 3 frames physiques
    gestionnaire = GestionnaireMemoire(taille_memoire_physique=3*4096)
    
    # Séquence d'accès aux pages
    sequence_acces = [1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5]
    
    print("Simulation d'accès aux pages:")
    for page in sequence_acces:
        print(f"\n--- Accès à la page {page} ---")
        gestionnaire.acceder_page(page)
        gestionnaire.afficher_etat()
```

### Système de fichiers

#### Structure hiérarchique

```
/                    (racine)
├── bin/            (exécutables système)
├── etc/            (fichiers de configuration)
├── home/           (répertoires utilisateurs)
│   ├── alice/
│   └── bob/
├── usr/            (programmes utilisateur)
│   ├── bin/
│   └── lib/
└── var/            (données variables)
    ├── log/
    └── tmp/
```

#### Opérations sur les fichiers

**Opérations de base :**
- Création (`create`)
- Ouverture (`open`)
- Lecture (`read`)
- Écriture (`write`)
- Positionnement (`seek`)
- Fermeture (`close`)
- Suppression (`delete`)

#### Implémentation simple d'un système de fichiers

```python
import json
import os
from datetime import datetime

class Fichier:
    def __init__(self, nom, contenu="", taille=0):
        self.nom = nom
        self.contenu = contenu
        self.taille = len(contenu)
        self.date_creation = datetime.now()
        self.date_modification = datetime.now()
        self.permissions = "rw-r--r--"  # Propriétaire: rw, Groupe: r, Autres: r
    
    def lire(self):
        return self.contenu
    
    def ecrire(self, nouveau_contenu):
        self.contenu = nouveau_contenu
        self.taille = len(nouveau_contenu)
        self.date_modification = datetime.now()
    
    def ajouter(self, contenu_supplementaire):
        self.contenu += contenu_supplementaire
        self.taille = len(self.contenu)
        self.date_modification = datetime.now()

class Repertoire:
    def __init__(self, nom):
        self.nom = nom
        self.fichiers = {}  # nom -> Fichier
        self.sous_repertoires = {}  # nom -> Repertoire
        self.date_creation = datetime.now()
        self.permissions = "rwxr-xr-x"
    
    def ajouter_fichier(self, fichier):
        self.fichiers[fichier.nom] = fichier
    
    def ajouter_repertoire(self, repertoire):
        self.sous_repertoires[repertoire.nom] = repertoire
    
    def lister_contenu(self):
        contenu = []
        for nom in self.sous_repertoires:
            contenu.append(f"d {nom}/")
        for nom in self.fichiers:
            fichier = self.fichiers[nom]
            contenu.append(f"- {nom} ({fichier.taille} octets)")
        return contenu
    
    def trouver_fichier(self, nom):
        return self.fichiers.get(nom)
    
    def trouver_repertoire(self, nom):
        return self.sous_repertoires.get(nom)

class SystemeFichiers:
    def __init__(self):
        self.racine = Repertoire("/")
        self.repertoire_courant = self.racine
        self.chemin_courant = "/"
    
    def analyser_chemin(self, chemin):
        """Analyse un chemin et retourne le répertoire et le nom du fichier"""
        if chemin.startswith("/"):
            # Chemin absolu
            parties = chemin.strip("/").split("/")
            repertoire = self.racine
        else:
            # Chemin relatif
            parties = chemin.split("/")
            repertoire = self.repertoire_courant
        
        # Naviguer dans les répertoires
        for partie in parties[:-1]:
            if partie == "..":
                # Remonter d'un niveau (simplifié)
                continue
            elif partie == "." or partie == "":
                continue
            else:
                repertoire = repertoire.trouver_repertoire(partie)
                if not repertoire:
                    raise FileNotFoundError(f"Répertoire '{partie}' introuvable")
        
        nom_fichier = parties[-1] if parties[-1] else None
        return repertoire, nom_fichier
    
    def creer_fichier(self, chemin, contenu=""):
        """Crée un nouveau fichier"""
        repertoire, nom_fichier = self.analyser_chemin(chemin)
        
        if nom_fichier in repertoire.fichiers:
            raise FileExistsError(f"Le fichier '{nom_fichier}' existe déjà")
        
        nouveau_fichier = Fichier(nom_fichier, contenu)
        repertoire.ajouter_fichier(nouveau_fichier)
        print(f"Fichier '{chemin}' créé")
    
    def lire_fichier(self, chemin):
        """Lit le contenu d'un fichier"""
        repertoire, nom_fichier = self.analyser_chemin(chemin)
        fichier = repertoire.trouver_fichier(nom_fichier)
        
        if not fichier:
            raise FileNotFoundError(f"Fichier '{chemin}' introuvable")
        
        return fichier.lire()
    
    def ecrire_fichier(self, chemin, contenu):
        """Écrit dans un fichier"""
        repertoire, nom_fichier = self.analyser_chemin(chemin)
        fichier = repertoire.trouver_fichier(nom_fichier)
        
        if not fichier:
            # Créer le fichier s'il n'existe pas
            self.creer_fichier(chemin, contenu)
        else:
            fichier.ecrire(contenu)
            print(f"Fichier '{chemin}' modifié")
    
    def creer_repertoire(self, chemin):
        """Crée un nouveau répertoire"""
        repertoire_parent, nom_repertoire = self.analyser_chemin(chemin)
        
        if nom_repertoire in repertoire_parent.sous_repertoires:
            raise FileExistsError(f"Le répertoire '{nom_repertoire}' existe déjà")
        
        nouveau_repertoire = Repertoire(nom_repertoire)
        repertoire_parent.ajouter_repertoire(nouveau_repertoire)
        print(f"Répertoire '{chemin}' créé")
    
    def lister_repertoire(self, chemin="."):
        """Liste le contenu d'un répertoire"""
        if chemin == ".":
            repertoire = self.repertoire_courant
        else:
            repertoire, _ = self.analyser_chemin(chemin)
        
        return repertoire.lister_contenu()
    
    def changer_repertoire(self, chemin):
        """Change le répertoire courant"""
        if chemin == "/":
            self.repertoire_courant = self.racine
            self.chemin_courant = "/"
        else:
            repertoire, nom = self.analyser_chemin(chemin)
            if nom:
                nouveau_repertoire = repertoire.trouver_repertoire(nom)
                if nouveau_repertoire:
                    self.repertoire_courant = nouveau_repertoire
                    # Mise à jour simplifiée du chemin
                    if self.chemin_courant.endswith("/"):
                        self.chemin_courant += nom
                    else:
                        self.chemin_courant += "/" + nom
                else:
                    raise FileNotFoundError(f"Répertoire '{chemin}' introuvable")
    
    def pwd(self):
        """Retourne le répertoire courant"""
        return self.chemin_courant

# Exemple d'utilisation
if __name__ == "__main__":
    # Créer un système de fichiers
    fs = SystemeFichiers()
    
    print("=== Démonstration du système de fichiers ===")
    
    # Créer des répertoires
    fs.creer_repertoire("home")
    fs.creer_repertoire("home/alice")
    fs.creer_repertoire("home/bob")
    
    # Créer des fichiers
    fs.creer_fichier("home/alice/document.txt", "Contenu du document d'Alice")
    fs.creer_fichier("home/bob/notes.txt", "Notes de Bob")
    
    # Lister le contenu
    print(f"\nContenu de / :")
    for item in fs.lister_repertoire("/"):
        print(f"  {item}")
    
    print(f"\nContenu de /home :")
    for item in fs.lister_repertoire("/home"):
        print(f"  {item}")
    
    # Lire un fichier
    print(f"\nContenu de /home/alice/document.txt :")
    print(fs.lire_fichier("/home/alice/document.txt"))
    
    # Changer de répertoire
    fs.changer_repertoire("home")
    print(f"\nRépertoire courant: {fs.pwd()}")
    
    # Modifier un fichier
    fs.ecrire_fichier("alice/document.txt", "Nouveau contenu du document")
    print(f"\nNouveau contenu:")
    print(fs.lire_fichier("alice/document.txt"))
```

---

## Réseaux informatiques

### Introduction aux réseaux

#### Définition
Un réseau informatique est un ensemble d'équipements interconnectés qui peuvent échanger des informations.

#### Types de réseaux

**Par étendue géographique :**
- **PAN** (Personal Area Network) : quelques mètres
- **LAN** (Local Area Network) : bâtiment ou campus
- **MAN** (Metropolitan Area Network) : ville
- **WAN** (Wide Area Network) : pays ou continent
- **Internet** : réseau mondial

**Par topologie :**
- **Bus** : tous les équipements sur un même câble
- **Étoile** : équipements connectés à un hub central
- **Anneau** : équipements connectés en boucle
- **Maillage** : connexions multiples entre équipements

### Modèle OSI et TCP/IP

#### Modèle OSI (7 couches)

```
┌─────────────────┐
│ 7. Application  │ ← HTTP, FTP, SMTP, DNS
├─────────────────┤
│ 6. Présentation │ ← Chiffrement, compression
├─────────────────┤
│ 5. Session      │ ← Gestion des sessions
├─────────────────┤
│ 4. Transport    │ ← TCP, UDP
├─────────────────┤
│ 3. Réseau       │ ← IP, routage
├─────────────────┤
│ 2. Liaison      │ ← Ethernet, WiFi
├─────────────────┤
│ 1. Physique     │ ← Câbles, signaux électriques
└─────────────────┘
```

#### Modèle TCP/IP (4 couches)

```
┌─────────────────┐
│   Application   │ ← HTTP, FTP, SMTP, DNS
├─────────────────┤
│   Transport     │ ← TCP, UDP
├─────────────────┤
│   Internet      │ ← IP
├─────────────────┤
│ Accès réseau    │ ← Ethernet, WiFi
└─────────────────┘
```

### Protocoles de communication

#### Protocole IP (Internet Protocol)

**Adressage IPv4 :**
- Format : 192.168.1.1 (4 octets)
- Classes d'adresses :
  - Classe A : 1.0.0.0 à 126.255.255.255
  - Classe B : 128.0.0.0 à 191.255.255.255
  - Classe C : 192.0.0.0 à 223.255.255.255

**Adresses privées :**
- 10.0.0.0/8 (10.0.0.0 à 10.255.255.255)
- 172.16.0.0/12 (172.16.0.0 à 172.31.255.255)
- 192.168.0.0/16 (192.168.0.0 à 192.168.255.255)

**Masque de sous-réseau :**
- Détermine la partie réseau et la partie hôte
- Exemple : 255.255.255.0 (/24)

#### Protocole TCP (Transmission Control Protocol)

**Caractéristiques :**
- Protocole fiable (avec accusé de réception)
- Contrôle de flux
- Détection et correction d'erreurs
- Établissement de connexion (3-way handshake)

**Établissement de connexion :**
```
Client                    Serveur
  │                         │
  │──── SYN ──────────────→ │
  │                         │
  │←──── SYN-ACK ──────────│
  │                         │
  │──── ACK ──────────────→ │
  │                         │
  │    Connexion établie    │
```

#### Protocole UDP (User Datagram Protocol)

**Caractéristiques :**
- Protocole non fiable (sans accusé de réception)
- Plus rapide que TCP
- Utilisé pour les applications temps réel
- Pas de contrôle de flux

### Simulation d'un réseau simple

```python
import socket
import threading
import time
import json
from queue import Queue

class Paquet:
    def __init__(self, source, destination, donnees, protocole="TCP"):
        self.source = source
        self.destination = destination
        self.donnees = donnees
        self.protocole = protocole
        self.timestamp = time.time()
        self.ttl = 64  # Time To Live
    
    def __str__(self):
        return f"{self.protocole}: {self.source} → {self.destination}: {self.donnees}"

class InterfaceReseau:
    def __init__(self, adresse_ip, masque="255.255.255.0"):
        self.adresse_ip = adresse_ip
        self.masque = masque
        self.file_reception = Queue()
        self.file_emission = Queue()
        self.actif = True
    
    def recevoir_paquet(self, paquet):
        if self.actif:
            self.file_reception.put(paquet)
            print(f"[{self.adresse_ip}] Paquet reçu: {paquet}")
    
    def envoyer_paquet(self, paquet):
        if self.actif:
            self.file_emission.put(paquet)
            print(f"[{self.adresse_ip}] Paquet envoyé: {paquet}")

class Routeur:
    def __init__(self, nom):
        self.nom = nom
        self.interfaces = {}  # nom_interface -> InterfaceReseau
        self.table_routage = {}  # reseau -> interface
        self.actif = True
        self.thread_routage = None
    
    def ajouter_interface(self, nom, adresse_ip, masque="255.255.255.0"):
        interface = InterfaceReseau(adresse_ip, masque)
        self.interfaces[nom] = interface
        print(f"[{self.nom}] Interface {nom} ajoutée: {adresse_ip}")
    
    def ajouter_route(self, reseau, interface_sortie):
        self.table_routage[reseau] = interface_sortie
        print(f"[{self.nom}] Route ajoutée: {reseau} via {interface_sortie}")
    
    def demarrer(self):
        self.thread_routage = threading.Thread(target=self.boucle_routage)
        self.thread_routage.daemon = True
        self.thread_routage.start()
    
    def boucle_routage(self):
        while self.actif:
            # Traiter les paquets de toutes les interfaces
            for nom_interface, interface in self.interfaces.items():
                if not interface.file_reception.empty():
                    paquet = interface.file_reception.get()
                    self.router_paquet(paquet, nom_interface)
            time.sleep(0.1)
    
    def router_paquet(self, paquet, interface_entree):
        print(f"[{self.nom}] Routage de {paquet} depuis {interface_entree}")
        
        # Décrémenter TTL
        paquet.ttl -= 1
        if paquet.ttl <= 0:
            print(f"[{self.nom}] Paquet abandonné (TTL expiré)")
            return
        
        # Trouver l'interface de sortie
        interface_sortie = self.trouver_route(paquet.destination)
        
        if interface_sortie and interface_sortie != interface_entree:
            # Transférer le paquet
            interface = self.interfaces[interface_sortie]
            interface.envoyer_paquet(paquet)
        else:
            print(f"[{self.nom}] Aucune route trouvée pour {paquet.destination}")
    
    def trouver_route(self, destination):
        # Recherche simple dans la table de routage
        for reseau, interface in self.table_routage.items():
            if destination.startswith(reseau):
                return interface
        return None

class Hote:
    def __init__(self, nom, adresse_ip):
        self.nom = nom
        self.adresse_ip = adresse_ip
        self.interface = InterfaceReseau(adresse_ip)
        self.passerelle = None
        self.applications = {}
    
    def definir_passerelle(self, passerelle):
        self.passerelle = passerelle
    
    def envoyer_message(self, destination, message, protocole="TCP"):
        paquet = Paquet(self.adresse_ip, destination, message, protocole)
        
        if self.passerelle:
            # Envoyer via la passerelle
            self.passerelle.recevoir_paquet_hote(paquet, self)
        else:
            print(f"[{self.nom}] Aucune passerelle configurée")
    
    def recevoir_paquet(self, paquet):
        print(f"[{self.nom}] Message reçu de {paquet.source}: {paquet.donnees}")
        
        # Simuler une réponse automatique pour certains protocoles
        if paquet.protocole == "TCP" and "ping" in paquet.donnees.lower():
            reponse = Paquet(self.adresse_ip, paquet.source, "pong", "TCP")
            if self.passerelle:
                self.passerelle.recevoir_paquet_hote(reponse, self)

class ReseauSimple:
    def __init__(self):
        self.routeurs = {}
        self.hotes = {}
        self.connexions = []  # (equipement1, interface1, equipement2, interface2)
    
    def ajouter_routeur(self, nom):
        routeur = Routeur(nom)
        self.routeurs[nom] = routeur
        return routeur
    
    def ajouter_hote(self, nom, adresse_ip):
        hote = Hote(nom, adresse_ip)
        self.hotes[nom] = hote
        return hote
    
    def connecter_equipements(self, eq1, int1, eq2, int2):
        self.connexions.append((eq1, int1, eq2, int2))
        print(f"Connexion: {eq1.nom}:{int1} ↔ {eq2.nom}:{int2}")
    
    def demarrer_simulation(self):
        # Démarrer tous les routeurs
        for routeur in self.routeurs.values():
            routeur.demarrer()
        
        print("Simulation réseau démarrée")
    
    def arreter_simulation(self):
        for routeur in self.routeurs.values():
            routeur.actif = False
        print("Simulation réseau arrêtée")

# Exemple d'utilisation
if __name__ == "__main__":
    # Créer un réseau simple
    reseau = ReseauSimple()
    
    # Ajouter des équipements
    routeur1 = reseau.ajouter_routeur("R1")
    routeur1.ajouter_interface("eth0", "192.168.1.1")
    routeur1.ajouter_interface("eth1", "10.0.0.1")
    
    hote1 = reseau.ajouter_hote("PC1", "192.168.1.10")
    hote2 = reseau.ajouter_hote("PC2", "10.0.0.10")
    
    # Configurer le routage
    routeur1.ajouter_route("192.168.1", "eth0")
    routeur1.ajouter_route("10.0.0", "eth1")
    
    # Configurer les passerelles
    hote1.definir_passerelle(routeur1)
    hote2.definir_passerelle(routeur1)
    
    # Simuler la réception de paquets par le routeur
    class PasserelleSimulee:
        def __init__(self, routeur):
            self.routeur = routeur
        
        def recevoir_paquet_hote(self, paquet, hote_source):
            # Déterminer l'interface d'entrée
            if hote_source.adresse_ip.startswith("192.168.1"):
                interface_entree = "eth0"
            else:
                interface_entree = "eth1"
            
            # Simuler la réception sur l'interface
            self.routeur.interfaces[interface_entree].recevoir_paquet(paquet)
    
    # Remplacer les passerelles par des simulées
    passerelle_sim = PasserelleSimulee(routeur1)
    hote1.passerelle = passerelle_sim
    hote2.passerelle = passerelle_sim
    
    # Démarrer la simulation
    reseau.demarrer_simulation()
    
    # Simuler des communications
    print("\n=== Test de communication ===")
    
    # PC1 envoie un message à PC2
    hote1.envoyer_message("10.0.0.10", "Hello from PC1!")
    
    time.sleep(0.5)
    
    # Simuler la livraison du paquet à PC2
    # (Dans une vraie simulation, ceci serait automatique)
    paquet_test = Paquet("192.168.1.10", "10.0.0.10", "Hello from PC1!", "TCP")
    hote2.recevoir_paquet(paquet_test)
    
    time.sleep(1)
    reseau.arreter_simulation()
```

### Services réseau

#### DNS (Domain Name System)

**Principe :**
- Traduction nom de domaine ↔ adresse IP
- Hiérarchie de serveurs DNS
- Cache pour améliorer les performances

**Types d'enregistrements :**
- **A** : nom → adresse IPv4
- **AAAA** : nom → adresse IPv6
- **CNAME** : alias vers un autre nom
- **MX** : serveur de messagerie
- **NS** : serveur de noms

#### DHCP (Dynamic Host Configuration Protocol)

**Principe :**
- Attribution automatique d'adresses IP
- Configuration réseau automatique
- Gestion centralisée

**Processus DHCP :**
1. **DISCOVER** : client cherche un serveur
2. **OFFER** : serveur propose une configuration
3. **REQUEST** : client demande la configuration
4. **ACK** : serveur confirme l'attribution

#### HTTP/HTTPS

**HTTP (HyperText Transfer Protocol) :**
- Protocole de communication web
- Méthodes : GET, POST, PUT, DELETE
- Codes de statut : 200 (OK), 404 (Not Found), 500 (Error)

**HTTPS :**
- HTTP sécurisé avec TLS/SSL
- Chiffrement des communications
- Authentification du serveur

### Sécurité réseau

#### Menaces courantes

**Écoute clandestine (Sniffing) :**
- Interception des communications
- Analyse du trafic réseau

**Usurpation d'identité (Spoofing) :**
- Falsification d'adresses IP/MAC
- Attaques man-in-the-middle

**Déni de service (DoS/DDoS) :**
- Saturation des ressources
- Indisponibilité des services

#### Mécanismes de protection

**Pare-feu (Firewall) :**
- Filtrage des paquets
- Contrôle d'accès par règles
- Inspection des protocoles

**Chiffrement :**
- Protection de la confidentialité
- Algorithmes symétriques et asymétriques
- Certificats numériques

**VPN (Virtual Private Network) :**
- Tunnel sécurisé sur Internet
- Chiffrement bout en bout
- Authentification forte

---

## Exercices pratiques

### Exercice 1 : Ordonnanceur de processus
Implémentez un ordonnanceur avec priorités dynamiques et mesurez les performances.

### Exercice 2 : Gestionnaire de mémoire virtuelle
Créez un simulateur de mémoire virtuelle avec différents algorithmes de remplacement.

### Exercice 3 : Système de fichiers
Étendez le système de fichiers avec la gestion des permissions et des liens.

### Exercice 4 : Protocole de communication
Implémentez un protocole de communication fiable sur UDP.

### Exercice 5 : Serveur web simple
Créez un serveur web basique gérant les requêtes HTTP GET et POST.

---

## Conclusion

Les systèmes d'exploitation et les réseaux constituent l'infrastructure fondamentale de l'informatique moderne. Leur compréhension est essentielle pour :

- **Développement** : Optimiser les applications
- **Administration** : Gérer les systèmes efficacement
- **Sécurité** : Protéger les ressources et données
- **Performance** : Identifier et résoudre les goulots d'étranglement

L'évolution vers le cloud computing, l'IoT et les systèmes distribués rend ces connaissances encore plus cruciales pour les informaticiens de demain.