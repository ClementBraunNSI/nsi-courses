<style>
.concept-section {
    margin: 2rem 0;
    padding: 1.5rem;
    border-radius: 12px;
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border-left: 4px solid #007bff;
}

.section-title {
    color: #2c3e50;
    font-size: 1.8rem;
    margin-bottom: 1.5rem;
    text-align: center;
    font-weight: 600;
}

.definition-box {
    background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
    border-radius: 10px;
    padding: 1.5rem;
    margin: 1.5rem 0;
    border-left: 4px solid #2196f3;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.definition-title {
    font-size: 1.2rem;
    font-weight: 600;
    color: #1565c0;
    margin-bottom: 0.8rem;
}

.definition-content {
    color: #37474f;
    line-height: 1.6;
    font-size: 1rem;
}

.concept-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1.5rem;
    margin: 2rem 0;
}

.concept-card {
    background: white;
    border-radius: 12px;
    padding: 1.5rem;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    border: 1px solid #e0e0e0;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.concept-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0,0,0,0.15);
}

.concept-icon {
    font-size: 2rem;
    margin-bottom: 1rem;
    text-align: center;
}

.concept-name {
    font-size: 1.1rem;
    font-weight: 600;
    color: #2c3e50;
    margin-bottom: 1rem;
    text-align: center;
}

.concept-description {
    color: #555;
    line-height: 1.6;
    text-align: left;
}

.code-example {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 1rem;
    margin: 1rem 0;
    border-left: 3px solid #28a745;
}

.code-title {
    font-size: 0.9rem;
    font-weight: 600;
    color: #28a745;
    margin-bottom: 0.5rem;
}

.code-example pre {
    margin: 0;
    background: none;
    padding: 0;
    border: none;
}

.graph-diagram {
    background: #f8f9fa;
    border-radius: 10px;
    padding: 1.5rem;
    margin: 1.5rem 0;
    text-align: center;
    border: 2px dashed #6c757d;
}

.comparison-table {
    width: 100%;
    border-collapse: collapse;
    margin: 1.5rem 0;
    background: white;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.comparison-table th {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 1rem;
    text-align: left;
    font-weight: 600;
}

.comparison-table td {
    padding: 1rem;
    border-bottom: 1px solid #e0e0e0;
    color: #37474f;
}

.comparison-table tr:nth-child(even) {
    background: #f8f9fa;
}

.highlight-fact {
    background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
    border-radius: 8px;
    padding: 1rem;
    margin: 1.5rem 0;
    border-left: 4px solid #ffc107;
    color: #856404;
    font-weight: 500;
}

.method-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
    gap: 1.5rem;
    margin: 2rem 0;
}

.method-card {
    background: white;
    border-radius: 12px;
    padding: 1.5rem;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    border-left: 4px solid #17a2b8;
}

.method-type {
    font-size: 1.1rem;
    font-weight: 600;
    color: #17a2b8;
    margin-bottom: 1rem;
}

.algorithm-card {
    background: linear-gradient(135deg, #e8f5e8 0%, #c8e6c9 100%);
    border-radius: 12px;
    padding: 1.5rem;
    margin: 1.5rem 0;
    border-left: 4px solid #4caf50;
}

.algorithm-title {
    font-size: 1.2rem;
    font-weight: 600;
    color: #2e7d32;
    margin-bottom: 1rem;
}

@media (max-width: 768px) {
    .concept-grid, .method-grid {
        grid-template-columns: 1fr;
    }
    
    .concept-section {
        padding: 1rem;
    }
    
    .section-title {
        font-size: 1.5rem;
    }
}
</style>

# üåê Les Graphes

<div class="concept-section">
    <h2 class="section-title">üéØ Introduction aux Graphes</h2>
    
    <div class="definition-box">
        <div class="definition-title">üìä Qu'est-ce qu'un graphe ?</div>
        <div class="definition-content">
            Un <strong>graphe</strong> est une structure de donn√©es fondamentale qui mod√©lise des <strong>relations entre des objets</strong>. Il constitue l'une des abstractions les plus puissantes en informatique pour repr√©senter des connexions complexes.
        </div>
    </div>
    
    <div class="concept-grid">
        <div class="concept-card">
            <div class="concept-icon">üîµ</div>
            <div class="concept-name">Sommets (N≈ìuds)</div>
            <div class="concept-description">
                Les <strong>objets</strong> ou <strong>entit√©s</strong> du graphe. Ils repr√©sentent les √©l√©ments que l'on souhaite connecter.
                <br><br>
                <em>Exemples :</em> Personnes, villes, pages web, ordinateurs...
            </div>
        </div>
        
        <div class="concept-card">
            <div class="concept-icon">üîó</div>
            <div class="concept-name">Ar√™tes (Arcs)</div>
            <div class="concept-description">
                Les <strong>relations</strong> ou <strong>connexions</strong> entre les sommets. Elles mat√©rialisent les liens qui unissent les objets.
                <br><br>
                <em>Exemples :</em> Amiti√©s, routes, liens hypertextes, c√¢bles r√©seau...
            </div>
        </div>
    </div>
    
    <div class="highlight-fact">
        üåç <strong>Omnipr√©sence :</strong> Les graphes sont partout en informatique : r√©seaux sociaux, GPS, Internet, circuits √©lectroniques, intelligence artificielle...
    </div>
</div>

<div class="concept-section">
    <h2 class="section-title">üîÑ Types de Graphes</h2>
    
    <div class="concept-grid">
        <div class="concept-card">
            <div class="concept-icon">‚ÜîÔ∏è</div>
            <div class="concept-name">Graphe Non Orient√©</div>
            <div class="concept-description">
                Les ar√™tes n'ont <strong>pas de direction</strong>. Si A est reli√© √† B, alors B est automatiquement reli√© √† A.
                
                <div class="graph-diagram">
                    <pre>A ---- B
|      |
C ---- D</pre>
                </div>
                
                <em>Exemple :</em> R√©seau d'amiti√© (relation sym√©trique)
            </div>
        </div>
        
        <div class="concept-card">
            <div class="concept-icon">‚û°Ô∏è</div>
            <div class="concept-name">Graphe Orient√©</div>
            <div class="concept-description">
                Les ar√™tes ont une <strong>direction</strong> pr√©cise (repr√©sent√©e par des fl√®ches).
                
                <div class="graph-diagram">
                    <pre>A ---> B
^      |
C <--- D</pre>
                </div>
                
                <em>Exemple :</em> R√©seau de followers (relation asym√©trique)
            </div>
        </div>
        
        <div class="concept-card">
            <div class="concept-icon">‚öñÔ∏è</div>
            <div class="concept-name">Graphe Pond√©r√©</div>
            <div class="concept-description">
                Les ar√™tes poss√®dent un <strong>poids</strong> (co√ªt, distance, temps, capacit√©...).
                
                <div class="graph-diagram">
                    <pre>A --5-- B
|       |
3       2
|       |
C --1-- D</pre>
                </div>
                
                <em>Exemple :</em> R√©seau routier avec distances
            </div>
        </div>
    </div>
</div>

<div class="concept-section">
    <h2 class="section-title">üíæ Repr√©sentations en M√©moire</h2>
    
    <div class="definition-box">
        <div class="definition-title">üéØ Choix de repr√©sentation</div>
        <div class="definition-content">
            Le choix de la repr√©sentation d√©pend de la <strong>densit√© du graphe</strong> et des <strong>op√©rations les plus fr√©quentes</strong>. Chaque approche a ses avantages selon le contexte d'utilisation.
        </div>
    </div>
    
    <div class="method-grid">
        <div class="method-card">
            <div class="method-type">üìä Matrice d'Adjacence</div>
            <div class="concept-description">
                Tableau 2D o√π <code>matrice[i][j]</code> indique s'il y a une ar√™te entre le sommet i et le sommet j.
                
                <div class="code-example">
                    <div class="code-title">üíª Exemple de matrice</div>
                    <pre><code># Graphe A-B-C avec A reli√© √† B et C
matrice = [
    [0, 1, 1],  # A : reli√© √† B(1) et C(2)
    [1, 0, 0],  # B : reli√© √† A(0)
    [1, 0, 0]   # C : reli√© √† A(0)
]</code></pre>
                </div>
                
                <div style="margin-top: 1rem;">
                    <strong style="color: #28a745;">‚úÖ Avantages :</strong>
                    <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
                        <li>V√©rification d'adjacence en O(1)</li>
                        <li>Simple √† impl√©menter</li>
                        <li>Id√©al pour les graphes denses</li>
                    </ul>
                    
                    <strong style="color: #dc3545;">‚ùå Inconv√©nients :</strong>
                    <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
                        <li>Espace O(n¬≤) m√™me pour graphes peu denses</li>
                        <li>Parcours des voisins en O(n)</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="method-card">
            <div class="method-type">üìã Liste d'Adjacence</div>
            <div class="concept-description">
                Chaque sommet maintient une liste de ses voisins directs.
                
                <div class="code-example">
                    <div class="code-title">üíª Exemple de liste</div>
                    <pre><code># M√™me graphe en liste d'adjacence
graphe = {
    'A': ['B', 'C'],
    'B': ['A'],
    'C': ['A']
}</code></pre>
                </div>
                
                <div style="margin-top: 1rem;">
                    <strong style="color: #28a745;">‚úÖ Avantages :</strong>
                    <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
                        <li>Espace O(n + m) o√π m = nombre d'ar√™tes</li>
                        <li>Parcours des voisins efficace</li>
                        <li>Id√©al pour les graphes peu denses</li>
                    </ul>
                    
                    <strong style="color: #dc3545;">‚ùå Inconv√©nients :</strong>
                    <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
                        <li>V√©rification d'adjacence en O(degr√©)</li>
                        <li>Plus complexe √† impl√©menter</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
    
    <table class="comparison-table">
        <thead>
            <tr>
                <th>Op√©ration</th>
                <th>Matrice d'Adjacence</th>
                <th>Liste d'Adjacence</th>
                <th>Recommandation</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>V√©rifier adjacence</td>
                <td>O(1)</td>
                <td>O(degr√©)</td>
                <td>Matrice pour fr√©quent</td>
            </tr>
            <tr>
                <td>Parcourir voisins</td>
                <td>O(n)</td>
                <td>O(degr√©)</td>
                <td>Liste plus efficace</td>
            </tr>
            <tr>
                <td>Espace m√©moire</td>
                <td>O(n¬≤)</td>
                <td>O(n + m)</td>
                <td>Liste pour graphes peu denses</td>
            </tr>
            <tr>
                <td>Ajouter ar√™te</td>
                <td>O(1)</td>
                <td>O(1)</td>
                <td>√âquivalent</td>
            </tr>
        </tbody>
    </table>
</div>

<div class="concept-section">
    <h2 class="section-title">üèóÔ∏è Impl√©mentation en Python</h2>
    
    <div class="definition-box">
        <div class="definition-title">üéØ Classe Graphe Compl√®te</div>
        <div class="definition-content">
            Impl√©mentation robuste utilisant les <strong>listes d'adjacence</strong> avec support des graphes orient√©s/non-orient√©s et pond√©r√©s.
        </div>
    </div>
    
    <div class="concept-grid">
        <div class="concept-card">
            <div class="concept-icon">üèõÔ∏è</div>
            <div class="concept-name">Structure de base</div>
            <div class="concept-description">
                Initialisation et gestion des sommets avec flexibilit√© d'orientation.
                
                <div class="code-example">
                    <div class="code-title">üíª Constructeur et ajout de sommets</div>
                    <pre><code>class Graphe:
    def __init__(self, oriente=False):
        self.sommets = {}  # dictionnaire : sommet -> liste des voisins
        self.oriente = oriente
    
    def ajouter_sommet(self, sommet):
        """Ajoute un sommet au graphe"""
        if sommet not in self.sommets:
            self.sommets[sommet] = []</code></pre>
                </div>
            </div>
        </div>
        
        <div class="concept-card">
            <div class="concept-icon">üîó</div>
            <div class="concept-name">Gestion des ar√™tes</div>
            <div class="concept-description">
                Ajout et suppression d'ar√™tes avec gestion automatique de l'orientation.
                
                <div class="code-example">
                    <div class="code-title">üíª M√©thodes d'ar√™tes</div>
                    <pre><code>def ajouter_arete(self, sommet1, sommet2, poids=1):
    """Ajoute une ar√™te entre deux sommets"""
    self.ajouter_sommet(sommet1)
    self.ajouter_sommet(sommet2)
    
    # Ajouter l'ar√™te
    self.sommets[sommet1].append((sommet2, poids))
    
    # Si non orient√©, ajouter l'ar√™te inverse
    if not self.oriente:
        self.sommets[sommet2].append((sommet1, poids))</code></pre>
                </div>
            </div>
        </div>
    </div>
    
    <div class="method-grid">
        <div class="method-card">
            <div class="method-type">üîç M√©thodes d'analyse</div>
            <div class="concept-description">
                Fonctions utilitaires pour analyser la structure du graphe.
            </div>
            
            <div class="code-example">
                <div class="code-title">üíª Analyse et v√©rification</div>
                <pre><code>def voisins(self, sommet):
    """Retourne la liste des voisins d'un sommet"""
    return self.sommets.get(sommet, [])

def est_adjacent(self, sommet1, sommet2):
    """V√©rifie si deux sommets sont adjacents"""
    return any(voisin == sommet2 for voisin, _ in self.voisins(sommet1))

def degre(self, sommet):
    """Retourne le degr√© d'un sommet"""
    return len(self.voisins(sommet))</code></pre>
            </div>
        </div>
        
        <div class="method-card">
            <div class="method-type">üóëÔ∏è Suppression d'ar√™tes</div>
            <div class="concept-description">
                Gestion de la suppression avec respect de l'orientation.
            </div>
            
            <div class="code-example">
                <div class="code-title">üíª Suppression intelligente</div>
                <pre><code>def supprimer_arete(self, sommet1, sommet2):
    """Supprime une ar√™te"""
    if sommet1 in self.sommets:
        self.sommets[sommet1] = [(v, p) for v, p in self.sommets[sommet1] 
                                if v != sommet2]
    
    if not self.oriente and sommet2 in self.sommets:
        self.sommets[sommet2] = [(v, p) for v, p in self.sommets[sommet2] 
                                if v != sommet1]</code></pre>
            </div>
        </div>
    </div>
    
    <div class="algorithm-card">
        <div class="algorithm-title">üöÄ Exemple d'utilisation pratique</div>
        
        <div class="code-example">
            <div class="code-title">üíª Construction et manipulation</div>
            <pre><code># Cr√©ation d'un graphe non orient√©
g = Graphe(oriente=False)

# Ajout des ar√™tes avec pond√©ration
g.ajouter_arete('A', 'B', 5)
g.ajouter_arete('A', 'C', 3)
g.ajouter_arete('B', 'D', 2)
g.ajouter_arete('C', 'D', 1)

# Analyse du graphe
print(f"Degr√© de A: {g.degre('A')}")  # 2
print(f"A et D adjacents: {g.est_adjacent('A', 'D')}")  # False
print(f"Voisins de B: {g.voisins('B')}")  # [('A', 5), ('D', 2)]</code></pre>
        </div>
        
        <div class="highlight-fact">
            üí° <strong>Flexibilit√© :</strong> Cette impl√©mentation supporte automatiquement les graphes orient√©s, non-orient√©s et pond√©r√©s selon les param√®tres fournis.
        </div>
    </div>
</div>

<div class="concept-section">
    <h2 class="section-title">üîç Algorithmes de Parcours</h2>
    
    <div class="definition-box">
        <div class="definition-title">üéØ Strat√©gies d'exploration</div>
        <div class="definition-content">
            Les algorithmes de parcours permettent d'<strong>explorer syst√©matiquement</strong> tous les sommets d'un graphe. Chaque strat√©gie a ses propres caract√©ristiques et applications sp√©cifiques.
        </div>
    </div>
    
    <div class="method-grid">
        <div class="method-card">
            <div class="method-type">üìä Parcours en Largeur (BFS)</div>
            <div class="concept-description">
                Explore le graphe <strong>niveau par niveau</strong> en utilisant une <strong>file (FIFO)</strong>. Id√©al pour trouver le plus court chemin.
                
                <div style="margin: 1rem 0; padding: 1rem; background: #e8f4fd; border-radius: 8px; border-left: 3px solid #2196f3;">
                    <strong>üéØ Principe :</strong> Visiter tous les voisins directs avant d'explorer plus loin
                </div>
                
                <div class="code-example">
                    <div class="code-title">üíª Impl√©mentation BFS</div>
                    <pre><code>from collections import deque

def parcours_largeur(graphe, sommet_depart):
    """Parcours en largeur (BFS)"""
    visites = set()
    file = deque([sommet_depart])
    ordre_visite = []
    
    while file:
        sommet = file.popleft()  # FIFO
        
        if sommet not in visites:
            visites.add(sommet)
            ordre_visite.append(sommet)
            
            # Ajouter les voisins non visit√©s
            for voisin, _ in graphe.voisins(sommet):
                if voisin not in visites:
                    file.append(voisin)
    
    return ordre_visite</code></pre>
                </div>
                
                <div style="margin-top: 1rem;">
                    <strong style="color: #28a745;">‚úÖ Applications :</strong>
                    <ul style="margin: 0.5rem 0; padding-left: 1.5rem; font-size: 0.9rem;">
                        <li>Plus court chemin (non pond√©r√©)</li>
                        <li>D√©tection de composantes connexes</li>
                        <li>Analyse de r√©seaux sociaux</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="method-card">
            <div class="method-type">üîÑ Parcours en Profondeur (DFS)</div>
            <div class="concept-description">
                Explore le graphe en allant <strong>le plus loin possible</strong> avant de revenir en arri√®re. Utilise une <strong>pile (LIFO)</strong> ou la r√©cursion.
                
                <div style="margin: 1rem 0; padding: 1rem; background: #f0f8e8; border-radius: 8px; border-left: 3px solid #4caf50;">
                    <strong>üéØ Principe :</strong> Aller au bout d'un chemin avant d'explorer les alternatives
                </div>
                
                <div class="code-example">
                    <div class="code-title">üíª Version r√©cursive</div>
                    <pre><code>def parcours_profondeur_recursif(graphe, sommet, visites=None):
    """Parcours en profondeur r√©cursif (DFS)"""
    if visites is None:
        visites = set()
    
    visites.add(sommet)
    print(sommet, end=' ')
    
    for voisin, _ in graphe.voisins(sommet):
        if voisin not in visites:
            parcours_profondeur_recursif(graphe, voisin, visites)</code></pre>
                </div>
                
                <div class="code-example">
                    <div class="code-title">üíª Version it√©rative</div>
                    <pre><code>def parcours_profondeur_iteratif(graphe, sommet_depart):
    """Parcours en profondeur it√©ratif (DFS)"""
    visites = set()
    pile = [sommet_depart]
    ordre_visite = []
    
    while pile:
        sommet = pile.pop()  # LIFO
        
        if sommet not in visites:
            visites.add(sommet)
            ordre_visite.append(sommet)
            
            # Ajouter les voisins (ordre inverse)
            for voisin, _ in reversed(graphe.voisins(sommet)):
                if voisin not in visites:
                    pile.append(voisin)
    
    return ordre_visite</code></pre>
                </div>
                
                <div style="margin-top: 1rem;">
                    <strong style="color: #28a745;">‚úÖ Applications :</strong>
                    <ul style="margin: 0.5rem 0; padding-left: 1.5rem; font-size: 0.9rem;">
                        <li>D√©tection de cycles</li>
                        <li>Tri topologique</li>
                        <li>R√©solution de labyrinthes</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
    
    <table class="comparison-table">
        <thead>
            <tr>
                <th>Crit√®re</th>
                <th>BFS (Largeur)</th>
                <th>DFS (Profondeur)</th>
                <th>Recommandation</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Structure de donn√©es</td>
                <td>File (FIFO)</td>
                <td>Pile (LIFO) / R√©cursion</td>
                <td>Selon l'objectif</td>
            </tr>
            <tr>
                <td>Complexit√© temporelle</td>
                <td>O(V + E)</td>
                <td>O(V + E)</td>
                <td>√âquivalent</td>
            </tr>
            <tr>
                <td>Complexit√© spatiale</td>
                <td>O(V)</td>
                <td>O(h) o√π h = hauteur</td>
                <td>DFS pour √©conomiser l'espace</td>
            </tr>
            <tr>
                <td>Plus court chemin</td>
                <td>‚úÖ Optimal</td>
                <td>‚ùå Non optimal</td>
                <td>BFS pour distances</td>
            </tr>
            <tr>
                <td>D√©tection de cycles</td>
                <td>‚úÖ Possible</td>
                <td>‚úÖ Plus naturel</td>
                <td>DFS plus simple</td>
            </tr>
        </tbody>
    </table>
    
    <div class="highlight-fact">
        üß† <strong>Choix strat√©gique :</strong> BFS pour l'exploration syst√©matique et les distances, DFS pour l'analyse structurelle et la d√©tection de motifs.
    </div>
</div>

<div class="concept-section">
    <h2 class="section-title">üßÆ Algorithmes Avanc√©s sur les Graphes</h2>
    
    <div class="definition-box">
        <div class="definition-title">üéØ Algorithmes fondamentaux</div>
        <div class="definition-content">
            Ces algorithmes r√©solvent des <strong>probl√®mes classiques</strong> sur les graphes : d√©tection de cycles, calcul de plus courts chemins, et analyse de connectivit√©.
        </div>
    </div>
    
    <div class="algorithm-card">
        <div class="algorithm-title">üîÑ D√©tection de Cycle</div>
        
        <div class="concept-description">
            Algorithme utilisant DFS pour d√©tecter la pr√©sence de cycles dans un graphe non orient√©.
            
            <div style="margin: 1rem 0; padding: 1rem; background: #fff3cd; border-radius: 8px; border-left: 3px solid #ffc107;">
                <strong>üí° Principe :</strong> Un cycle existe si on rencontre un sommet d√©j√† visit√© qui n'est pas le parent direct
            </div>
        </div>
        
        <div class="code-example">
            <div class="code-title">üíª Impl√©mentation d√©tection de cycle</div>
            <pre><code>def a_un_cycle(graphe):
    """D√©tecte s'il y a un cycle dans un graphe non orient√©"""
    visites = set()
    
    def dfs(sommet, parent):
        visites.add(sommet)
        
        for voisin, _ in graphe.voisins(sommet):
            if voisin not in visites:
                if dfs(voisin, sommet):
                    return True
            elif voisin != parent:  # Cycle d√©tect√© !
                return True
        
        return False
    
    # V√©rifier chaque composante connexe
    for sommet in graphe.sommets:
        if sommet not in visites:
            if dfs(sommet, None):
                return True
    
    return False</code></pre>
        </div>
    </div>
    
    <div class="algorithm-card">
        <div class="algorithm-title">üõ£Ô∏è Algorithme de Dijkstra</div>
        
        <div class="concept-description">
            Calcule le plus court chemin depuis un sommet source vers tous les autres sommets dans un graphe pond√©r√©.
            
            <div style="margin: 1rem 0; padding: 1rem; background: #e8f5e8; border-radius: 8px; border-left: 3px solid #4caf50;">
                <strong>‚ö° Complexit√© :</strong> O((V + E) log V) avec une file de priorit√©
            </div>
        </div>
        
        <div class="method-grid">
            <div class="method-card">
                <div class="method-type">üéØ Algorithme principal</div>
                
                <div class="code-example">
                    <div class="code-title">üíª Dijkstra complet</div>
                    <pre><code>import heapq

def dijkstra(graphe, depart):
    """Algorithme de Dijkstra pour le plus court chemin"""
    distances = {sommet: float('inf') for sommet in graphe.sommets}
    distances[depart] = 0
    predecesseurs = {}
    
    # File de priorit√© : (distance, sommet)
    file_priorite = [(0, depart)]
    
    while file_priorite:
        distance_actuelle, sommet_actuel = heapq.heappop(file_priorite)
        
        # Optimisation : ignorer si d√©j√† trait√©
        if distance_actuelle > distances[sommet_actuel]:
            continue
        
        # Examiner tous les voisins
        for voisin, poids in graphe.voisins(sommet_actuel):
            nouvelle_distance = distance_actuelle + poids
            
            if nouvelle_distance < distances[voisin]:
                distances[voisin] = nouvelle_distance
                predecesseurs[voisin] = sommet_actuel
                heapq.heappush(file_priorite, (nouvelle_distance, voisin))
    
    return distances, predecesseurs</code></pre>
                </div>
            </div>
            
            <div class="method-card">
                <div class="method-type">üîÑ Reconstruction de chemin</div>
                
                <div class="code-example">
                    <div class="code-title">üíª R√©cup√©ration du chemin</div>
                    <pre><code>def reconstruire_chemin(predecesseurs, depart, arrivee):
    """Reconstruit le chemin √† partir des pr√©d√©cesseurs"""
    chemin = []
    sommet = arrivee
    
    while sommet is not None:
        chemin.append(sommet)
        sommet = predecesseurs.get(sommet)
    
    chemin.reverse()
    return chemin if chemin[0] == depart else []

# Exemple d'utilisation
distances, predecesseurs = dijkstra(graphe, 'A')
chemin_vers_D = reconstruire_chemin(predecesseurs, 'A', 'D')
print(f"Plus court chemin A‚ÜíD: {chemin_vers_D}")
print(f"Distance: {distances['D']}")</code></pre>
                </div>
            </div>
        </div>
        
        <div class="highlight-fact">
            üöÄ <strong>Performance :</strong> Dijkstra est optimal pour les graphes avec poids positifs. Pour les poids n√©gatifs, utiliser Bellman-Ford.
        </div>
    </div>
</div>

<div class="concept-section">
    <h2 class="section-title">üåç Applications Pratiques des Graphes</h2>
    
    <div class="definition-box">
        <div class="definition-title">üéØ Domaines d'application</div>
        <div class="definition-content">
            Les graphes mod√©lisent de nombreux <strong>syst√®mes r√©els</strong> : r√©seaux sociaux, syst√®mes de navigation, r√©seaux informatiques, analyse de donn√©es, etc.
        </div>
    </div>
    
    <div class="concept-grid">
        <div class="concept-card">
            <div class="concept-icon">üë•</div>
            <div class="concept-name">R√©seaux Sociaux</div>
            <div class="concept-description">
                <strong>Mod√©lisation :</strong> Utilisateurs = sommets, Relations = ar√™tes
                <br><strong>Algorithmes :</strong> Suggestions d'amis, communaut√©s, influence
            </div>
        </div>
        
        <div class="concept-card">
            <div class="concept-icon">üó∫Ô∏è</div>
            <div class="concept-name">Navigation GPS</div>
            <div class="concept-description">
                <strong>Mod√©lisation :</strong> Intersections = sommets, Routes = ar√™tes pond√©r√©es
                <br><strong>Algorithmes :</strong> Plus court chemin, optimisation de trajets
            </div>
        </div>
        
        <div class="concept-card">
            <div class="concept-icon">üåê</div>
            <div class="concept-name">R√©seaux Informatiques</div>
            <div class="concept-description">
                <strong>Mod√©lisation :</strong> Routeurs = sommets, Connexions = ar√™tes
                <br><strong>Algorithmes :</strong> Routage, d√©tection de pannes, optimisation
            </div>
        </div>
        
        <div class="concept-card">
            <div class="concept-icon">üìä</div>
            <div class="concept-name">Analyse de Donn√©es</div>
            <div class="concept-description">
                <strong>Mod√©lisation :</strong> Entit√©s = sommets, Relations = ar√™tes
                <br><strong>Algorithmes :</strong> Clustering, classification, recommandations
            </div>
        </div>
    </div>
    
    <div class="algorithm-card">
        <div class="algorithm-title">üë• Exemple : R√©seau Social</div>
        
        <div class="code-example">
            <div class="code-title">üíª Impl√©mentation r√©seau social</div>
            <pre><code>class ReseauSocial:
    def __init__(self):
        self.graphe = Graphe(oriente=False)
    
    def ajouter_personne(self, nom):
        self.graphe.ajouter_sommet(nom)
    
    def ajouter_amitie(self, personne1, personne2):
        self.graphe.ajouter_arete(personne1, personne2)
    
    def amis_communs(self, personne1, personne2):
        """Trouve les amis communs entre deux personnes"""
        amis1 = {voisin for voisin, _ in self.graphe.voisins(personne1)}
        amis2 = {voisin for voisin, _ in self.graphe.voisins(personne2)}
        return amis1.intersection(amis2)
    
    def suggestions_amis(self, personne):
        """Sugg√®re des amis bas√© sur les amis d'amis"""
        amis_directs = {voisin for voisin, _ in self.graphe.voisins(personne)}
        suggestions = set()
        
        for ami in amis_directs:
            for ami_dami, _ in self.graphe.voisins(ami):
                if ami_dami != personne and ami_dami not in amis_directs:
                    suggestions.add(ami_dami)
        
        return suggestions
    
    def degre_separation(self, personne1, personne2):
        """Calcule le degr√© de s√©paration (distance) entre deux personnes"""
        distances, _ = dijkstra(self.graphe, personne1)
        return distances.get(personne2, float('inf'))</code></pre>
        </div>
        
        <div class="highlight-fact">
            üí° <strong>Algorithme de suggestion :</strong> Bas√© sur le principe "les amis de mes amis sont mes amis potentiels"
        </div>
    </div>
    
    <div class="algorithm-card">
        <div class="algorithm-title">üó∫Ô∏è Exemple : Syst√®me de Navigation</div>
        
        <div class="code-example">
            <div class="code-title">üíª Impl√©mentation GPS</div>
            <pre><code>class CarteRoutiere:
    def __init__(self):
        self.graphe = Graphe(oriente=False)
    
    def ajouter_route(self, ville1, ville2, distance):
        self.graphe.ajouter_arete(ville1, ville2, distance)
    
    def plus_court_chemin(self, depart, arrivee):
        """Trouve le plus court chemin entre deux villes"""
        distances, predecesseurs = dijkstra(self.graphe, depart)
        
        if distances[arrivee] == float('inf'):
            return None, float('inf')
        
        chemin = reconstruire_chemin(predecesseurs, depart, arrivee)
        return chemin, distances[arrivee]
    
    def itineraire_complet(self, depart, arrivee):
        """Retourne un itin√©raire d√©taill√©"""
        chemin, distance = self.plus_court_chemin(depart, arrivee)
        
        if chemin is None:
            return None
        
        return {
            'chemin': chemin,
            'distance_totale': distance,
            'etapes': len(chemin) - 1,
            'villes_traversees': len(chemin)
        }

# Exemple d'utilisation
carte = CarteRoutiere()
carte.ajouter_route("Paris", "Lyon", 465)
carte.ajouter_route("Lyon", "Marseille", 315)

itineraire = carte.itineraire_complet("Paris", "Marseille")
if itineraire:
    print(f"Trajet: {' ‚Üí '.join(itineraire['chemin'])}")
    print(f"Distance: {itineraire['distance_totale']} km")</code></pre>
        </div>
        
        <div class="highlight-fact">
            üöó <strong>Optimisation r√©elle :</strong> Les GPS modernes int√®grent trafic, p√©ages, pr√©f√©rences utilisateur
        </div>
    </div>
</div>

<div class="concept-section">
    <h2 class="section-title">‚ö° Analyse de Complexit√©</h2>
    
    <div class="definition-box">
        <div class="definition-title">üìä Comparaison des performances</div>
        <div class="definition-content">
            Le choix de la repr√©sentation impacte directement les <strong>performances</strong> selon les op√©rations effectu√©es.
        </div>
    </div>
    
    <table class="comparison-table">
        <thead>
            <tr>
                <th>Op√©ration</th>
                <th>Matrice d'adjacence</th>
                <th>Liste d'adjacence</th>
                <th>Meilleur choix</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Ajouter sommet</td>
                <td>O(n¬≤)</td>
                <td>O(1)</td>
                <td>Liste d'adjacence</td>
            </tr>
            <tr>
                <td>Ajouter ar√™te</td>
                <td>O(1)</td>
                <td>O(1)</td>
                <td>√âquivalent</td>
            </tr>
            <tr>
                <td>Supprimer ar√™te</td>
                <td>O(1)</td>
                <td>O(degr√©)</td>
                <td>Matrice d'adjacence</td>
            </tr>
            <tr>
                <td>V√©rifier adjacence</td>
                <td>O(1)</td>
                <td>O(degr√©)</td>
                <td>Matrice d'adjacence</td>
            </tr>
            <tr>
                <td>Parcours complet</td>
                <td>O(n¬≤)</td>
                <td>O(n + m)</td>
                <td>Liste pour graphes peu denses</td>
            </tr>
            <tr>
                <td>Espace m√©moire</td>
                <td>O(n¬≤)</td>
                <td>O(n + m)</td>
                <td>Liste pour graphes peu denses</td>
            </tr>
        </tbody>
    </table>
    
    <div class="concept-grid">
        <div class="concept-card">
            <div class="concept-icon">üìà</div>
            <div class="concept-name">Notation Big O</div>
            <div class="concept-description">
                <strong>n</strong> = nombre de sommets<br>
                <strong>m</strong> = nombre d'ar√™tes<br>
                <strong>degr√©</strong> = nombre de voisins d'un sommet<br>
                <strong>V</strong> = vertices (sommets)<br>
                <strong>E</strong> = edges (ar√™tes)
            </div>
        </div>
        
        <div class="concept-card">
            <div class="concept-icon">üéØ</div>
            <div class="concept-name">R√®gles de choix</div>
            <div class="concept-description">
                <strong>Matrice :</strong> Graphes denses, v√©rifications fr√©quentes<br>
                <strong>Liste :</strong> Graphes peu denses, parcours fr√©quents<br>
                <strong>Seuil :</strong> m ‚âà n¬≤/2 pour choisir
            </div>
        </div>
    </div>
</div>

<div class="concept-section">
    <h2 class="section-title">üéì Synth√®se et Conclusion</h2>
    
    <div class="definition-box">
        <div class="definition-title">üåü Les graphes : une abstraction fondamentale</div>
        <div class="definition-content">
            Les graphes constituent l'une des <strong>structures de donn√©es les plus polyvalentes</strong> en informatique, permettant de mod√©liser et r√©soudre une multitude de probl√®mes complexes.
        </div>
    </div>
    
    <div class="concept-grid">
        <div class="concept-card">
            <div class="concept-icon">üîß</div>
            <div class="concept-name">Concepts Fondamentaux</div>
            <div class="concept-description">
                <strong>‚Ä¢ Structure :</strong> Sommets + Ar√™tes<br>
                <strong>‚Ä¢ Types :</strong> Orient√©/Non-orient√©, Pond√©r√©<br>
                <strong>‚Ä¢ Repr√©sentations :</strong> Matrice vs Liste<br>
                <strong>‚Ä¢ Flexibilit√© :</strong> Adaptation au contexte
            </div>
        </div>
        
        <div class="concept-card">
            <div class="concept-icon">üöÄ</div>
            <div class="concept-name">Algorithmes Essentiels</div>
            <div class="concept-description">
                <strong>‚Ä¢ Parcours :</strong> BFS (largeur) et DFS (profondeur)<br>
                <strong>‚Ä¢ Chemins :</strong> Dijkstra pour plus courts chemins<br>
                <strong>‚Ä¢ Analyse :</strong> D√©tection de cycles, connectivit√©<br>
                <strong>‚Ä¢ Complexit√© :</strong> O(V + E) pour la plupart
            </div>
        </div>
        
        <div class="concept-card">
            <div class="concept-icon">üåç</div>
            <div class="concept-name">Applications R√©elles</div>
            <div class="concept-description">
                <strong>‚Ä¢ R√©seaux sociaux :</strong> Relations, suggestions<br>
                <strong>‚Ä¢ Navigation :</strong> GPS, optimisation de trajets<br>
                <strong>‚Ä¢ Internet :</strong> Routage, pages web<br>
                <strong>‚Ä¢ IA :</strong> Recherche, planification
            </div>
        </div>
        
        <div class="concept-card">
            <div class="concept-icon">‚öñÔ∏è</div>
            <div class="concept-name">Choix Strat√©giques</div>
            <div class="concept-description">
                <strong>‚Ä¢ Densit√© :</strong> Crit√®re de choix principal<br>
                <strong>‚Ä¢ Op√©rations :</strong> Fr√©quence d'utilisation<br>
                <strong>‚Ä¢ M√©moire :</strong> Contraintes d'espace<br>
                <strong>‚Ä¢ Performance :</strong> Optimisation cibl√©e
            </div>
        </div>
    </div>
    
    <div class="algorithm-card">
        <div class="algorithm-title">üéØ Points Cl√©s √† Retenir</div>
        
        <div class="highlight-fact">
            üß† <strong>Mod√©lisation :</strong> Identifier les entit√©s (sommets) et leurs relations (ar√™tes) est la premi√®re √©tape cruciale
        </div>
        
        <div class="highlight-fact">
            ‚ö° <strong>Performance :</strong> Le choix matrice vs liste d√©pend de la densit√© : liste pour graphes peu denses (m << n¬≤)
        </div>
        
        <div class="highlight-fact">
            üîç <strong>Algorithmes :</strong> BFS pour distances minimales, DFS pour exploration exhaustive et d√©tection de cycles
        </div>
        
        <div class="highlight-fact">
            üåê <strong>Universalit√© :</strong> Les graphes sont omnipr√©sents : du GPS aux r√©seaux sociaux, en passant par l'IA
        </div>
        
        <div class="highlight-fact">
            üöÄ <strong>√âvolutivit√© :</strong> Les algorithmes sur graphes s'adaptent naturellement aux gros volumes de donn√©es
        </div>
    </div>
    
    <div class="definition-box">
        <div class="definition-title">üîÆ Perspectives d'approfondissement</div>
        <div class="definition-content">
            <strong>Algorithmes avanc√©s :</strong> Bellman-Ford, Floyd-Warshall, Kruskal, Prim<br>
            <strong>Graphes sp√©cialis√©s :</strong> Arbres, DAG, graphes bipartites<br>
            <strong>Applications avanc√©es :</strong> Machine Learning, analyse de r√©seaux, optimisation
        </div>
    </div>
</div>